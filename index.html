<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDFæ•´ç†ãƒ„ãƒ¼ãƒ«</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- PDF Libraries -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        body { font-family: 'Inter', system-ui, -apple-system, sans-serif; }
        
        /* Drag & Drop Styles */
        .drag-over-zone { background-color: #eef2ff; border-color: #6366f1; }
        .dragging-page { opacity: 0.4; }
        
        /* Insertion Indicator Bar */
        .insertion-bar {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 4px;
            background-color: #4f46e5; /* indigo-600 */
            border-radius: 2px;
            z-index: 50;
            pointer-events: none;
            box-shadow: 0 0 8px rgba(79, 70, 229, 0.6);
        }
        .insertion-bar.left { left: -8px; }
        .insertion-bar.right { right: -8px; }

        /* Spinner Animation */
        @keyframes spin { to { transform: rotate(360deg); } }
        .animate-spin { animation: spin 1s linear infinite; }
    </style>
</head>
<body class="bg-slate-100 min-h-screen text-slate-800">

    <div id="app" class="min-h-screen flex flex-col">
        <!-- Content injected by JS -->
    </div>

    <!-- Hidden file input for adding more PDFs -->
    <input type="file" id="add-file-input" accept=".pdf" class="hidden" multiple />

    <script>
        // --- State Management ---
        const state = {
            // List of loaded PDF source files { id, name, arrayBuffer }
            sources: [], 
            // List of pages to display { id, sourceId, originalIndex, displayNumber, imageUrl }
            pages: [],
            
            isProcessing: false,
            progress: 0,
            statusMessage: '', // e.g. "2ã¤ç›®ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ä¸­..."
            
            // Drag & Drop State
            draggedPageIndex: null,     // Index of the page being dragged
            dropTargetIndex: null,      // Index of the page being hovered
            dropPosition: null,         // 'left' or 'right'
            isFileDragging: false       // Is a file being dragged over the window?
        };

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            if (window.pdfjsLib) {
                window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
            }
            
            // ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—ã‚¤ãƒ™ãƒ³ãƒˆã‚’åˆå›ã®ã¿ç™»éŒ²ï¼ˆé‡è¤‡ç™ºç«é˜²æ­¢ï¼‰
            setupGlobalDragEvents();
            
            render();
        });

        // --- Core Logic ---

        // Handle file selection (Initial or Add)
        async function handleFileSelect(event) {
            // å‡¦ç†ä¸­ã®é‡è¤‡å®Ÿè¡Œã‚’ãƒ–ãƒ­ãƒƒã‚¯ã™ã‚‹ï¼ˆãƒã‚°ä¿®æ­£ã®è¦ï¼‰
            if (state.isProcessing) return;

            const files = event.target.files ? Array.from(event.target.files) : Array.from(event.dataTransfer.files);
            const pdfFiles = files.filter(f => f.type === 'application/pdf');

            if (pdfFiles.length === 0) {
                return;
            }

            await processPDFs(pdfFiles);
            
            // Reset input
            if (event.target && event.target.value !== undefined) {
                event.target.value = '';
            }
        }

        async function processPDFs(files) {
            if (!window.pdfjsLib) {
                alert("ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®èª­ã¿è¾¼ã¿ãŒå®Œäº†ã—ã¦ã„ã¾ã›ã‚“ã€‚ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚");
                return;
            }

            state.isProcessing = true;
            state.progress = 0;
            
            // Determine starting status message
            const isAdding = state.pages.length > 0;
            state.statusMessage = isAdding ? "ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¿½åŠ ä¸­..." : "PDFã‚’èª­ã¿è¾¼ã‚“ã§ã„ã¾ã™...";
            render();

            try {
                for (let fIndex = 0; fIndex < files.length; fIndex++) {
                    const file = files[fIndex];
                    const sourceId = `src-${Date.now()}-${fIndex}`;
                    const arrayBuffer = await file.arrayBuffer();
                    
                    // Store source securely
                    state.sources.push({
                        id: sourceId,
                        name: file.name,
                        arrayBuffer: arrayBuffer.slice(0) // Clone buffer
                    });

                    // Load PDF document
                    const loadingTask = window.pdfjsLib.getDocument(arrayBuffer);
                    const pdf = await loadingTask.promise;
                    const numPages = pdf.numPages;

                    // Render pages
                    for (let i = 1; i <= numPages; i++) {
                        const page = await pdf.getPage(i);
                        const viewport = page.getViewport({ scale: 0.5 });
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.height = viewport.height;
                        canvas.width = viewport.width;

                        await page.render({
                            canvasContext: context,
                            viewport: viewport
                        }).promise;

                        state.pages.push({
                            id: `p-${sourceId}-${i}`,
                            sourceId: sourceId,
                            originalIndex: i - 1, // 0-based for pdf-lib
                            displayNumber: i,
                            imageUrl: canvas.toDataURL()
                        });

                        state.progress = Math.round((i / numPages) * 100);
                        if (files.length > 1) {
                            state.statusMessage = `${file.name} ã‚’å‡¦ç†ä¸­ (${fIndex + 1}/${files.length})...`;
                        }
                        render(); 
                    }
                }
            } catch (error) {
                console.error("Error processing PDF:", error);
                alert("PDFã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ä¿è­·ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ç­‰ã¯å¯¾å¿œã—ã¦ã„ãªã„å ´åˆãŒã‚ã‚Šã¾ã™ã€‚");
            } finally {
                state.isProcessing = false;
                state.statusMessage = '';
                render();
            }
        }

        async function saveNewPDF() {
            if (state.pages.length === 0) return;

            state.isProcessing = true;
            state.statusMessage = "PDFã‚’ä½œæˆä¸­...";
            render();

            try {
                const { PDFDocument } = window.PDFLib;
                const newPdfDoc = await PDFDocument.create();

                // Cache loaded source documents to avoid reloading multiple times
                const loadedDocs = {}; // sourceId -> PDFDocument

                for (const page of state.pages) {
                    // Load source doc if not already loaded
                    if (!loadedDocs[page.sourceId]) {
                        const source = state.sources.find(s => s.id === page.sourceId);
                        if (!source) continue;
                        loadedDocs[page.sourceId] = await PDFDocument.load(source.arrayBuffer);
                    }

                    const srcDoc = loadedDocs[page.sourceId];
                    // Copy page
                    const [copiedPage] = await newPdfDoc.copyPages(srcDoc, [page.originalIndex]);
                    newPdfDoc.addPage(copiedPage);
                }

                const pdfBytes = await newPdfDoc.save();
                
                // Generate filename
                const baseName = state.sources[0]?.name.replace('.pdf', '') || 'document';
                const fileName = `merged_${baseName}.pdf`;

                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = fileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

            } catch (error) {
                console.error("Error saving PDF:", error);
                alert("ä¿å­˜ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚");
            } finally {
                state.isProcessing = false;
                render();
            }
        }

        function resetAll() {
            if (confirm("ã™ã¹ã¦ã®å¤‰æ›´ã‚’ç ´æ£„ã—ã¦åˆæœŸçŠ¶æ…‹ã«æˆ»ã—ã¾ã™ã‹ï¼Ÿ")) {
                state.sources = [];
                state.pages = [];
                state.dropTargetIndex = null;
                render();
            }
        }

        function removePage(index) {
            state.pages.splice(index, 1);
            render();
        }

        function triggerAddFile() {
            document.getElementById('add-file-input').click();
        }

        // --- Drag and Drop Logic (Page Reordering) ---
        
        function handlePageDragStart(e, index) {
            state.draggedPageIndex = index;
            e.dataTransfer.effectAllowed = "move";
            e.dataTransfer.setData('text/plain', index); // Required for Firefox
            
            setTimeout(() => {
                const el = document.querySelector(`[data-index="${index}"]`);
                if(el) el.classList.add('dragging-page');
            }, 0);
        }

        function handlePageDragOver(e, targetIndex) {
            e.preventDefault();
            if (state.draggedPageIndex === null) return; 
            if (state.draggedPageIndex === targetIndex) {
                state.dropTargetIndex = null;
                state.dropPosition = null;
                renderInsertionUI();
                return;
            }

            const targetEl = e.currentTarget;
            const rect = targetEl.getBoundingClientRect();
            const mouseX = e.clientX;
            
            const isRight = mouseX > rect.left + rect.width / 2;
            
            state.dropTargetIndex = targetIndex;
            state.dropPosition = isRight ? 'right' : 'left';
            
            renderInsertionUI();
        }

        function handlePageDrop(e) {
            e.preventDefault();
            if (state.draggedPageIndex === null) return;
            
            const fromIndex = state.draggedPageIndex;
            const toIndex = state.dropTargetIndex;
            const position = state.dropPosition;

            if (toIndex !== null && position) {
                const item = state.pages[fromIndex];
                
                state.pages.splice(fromIndex, 1);
                
                let insertAtIndex = toIndex;
                if (fromIndex < toIndex) {
                    insertAtIndex = position === 'left' ? toIndex - 1 : toIndex;
                } else {
                    insertAtIndex = position === 'left' ? toIndex : toIndex + 1;
                }
                
                state.pages.splice(insertAtIndex, 0, item);
            }

            resetDragState();
            render();
        }

        function handlePageDragEnd(e) {
            resetDragState();
            render();
        }

        function resetDragState() {
            state.draggedPageIndex = null;
            state.dropTargetIndex = null;
            state.dropPosition = null;
            renderInsertionUI(); 
        }

        function renderInsertionUI() {
            document.querySelectorAll('.insertion-bar').forEach(el => el.remove());
            
            if (state.dropTargetIndex !== null && state.dropPosition) {
                const targetEl = document.querySelector(`[data-index="${state.dropTargetIndex}"] .preview-container`);
                if (targetEl) {
                    const bar = document.createElement('div');
                    bar.className = `insertion-bar ${state.dropPosition}`;
                    targetEl.appendChild(bar);
                }
            }
        }

        // --- Drag and Drop Logic (File Upload) ---

        function setupGlobalDragEvents() {
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                window.addEventListener(eventName, preventDefaults, false);
            });

            window.addEventListener('dragenter', (e) => {
                // ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‰ãƒ©ãƒƒã‚°ã§ã‚ã‚Šã€ãƒšãƒ¼ã‚¸ä¸¦ã¹æ›¿ãˆã®ãƒ‰ãƒ©ãƒƒã‚°ã§ã¯ãªã„å ´åˆã®ã¿ç™ºç«
                if (e.dataTransfer.types.includes('Files') && state.draggedPageIndex === null) {
                    state.isFileDragging = true;
                    updateFileDragUI();
                }
            });

            window.addEventListener('dragleave', (e) => {
                // ç”»é¢å¤–ã«ã‚«ãƒ¼ã‚½ãƒ«ãŒå‡ºãŸå ´åˆã®ã¿ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’æ¶ˆã™
                if (e.clientX <= 0 || e.clientY <= 0 || e.clientX >= window.innerWidth || e.clientY >= window.innerHeight) {
                    state.isFileDragging = false;
                    updateFileDragUI();
                }
            });

            window.addEventListener('drop', (e) => {
                if (state.isFileDragging) {
                    state.isFileDragging = false;
                    updateFileDragUI();
                    
                    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                        handleFileSelect(e);
                    }
                }
            });
        }

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function updateFileDragUI() {
            const overlay = document.getElementById('file-drag-overlay');
            if (overlay) {
                if (state.isFileDragging) {
                    overlay.classList.remove('hidden');
                } else {
                    overlay.classList.add('hidden');
                }
            }
        }

        // --- Rendering ---

        function render() {
            const app = document.getElementById('app');
            
            if (state.isProcessing) {
                app.innerHTML = renderProcessing();
                lucide.createIcons();
                return;
            }

            if (state.pages.length === 0) {
                app.innerHTML = renderInitialUpload();
                setupInitialUploadEvents();
            } else {
                app.innerHTML = renderEditor();
                setupEditorEvents();
            }
            
            lucide.createIcons();

            const addInput = document.getElementById('add-file-input');
            if(addInput) addInput.onchange = handleFileSelect;
        }

        function renderProcessing() {
            return `
            <div class="min-h-screen flex flex-col items-center justify-center bg-slate-100 z-50">
                <div class="w-16 h-16 border-4 border-indigo-200 border-t-indigo-600 rounded-full animate-spin mb-6"></div>
                <h2 class="text-xl font-bold text-slate-700 mb-2">å‡¦ç†ä¸­...</h2>
                <p class="text-slate-500 mb-4">${state.statusMessage}</p>
                <div class="w-64 bg-slate-200 rounded-full h-2.5">
                    <div class="bg-indigo-600 h-2.5 rounded-full transition-all duration-300" style="width: ${state.progress}%"></div>
                </div>
            </div>`;
        }

        function renderInitialUpload() {
            return `
            <div class="min-h-screen bg-slate-50 flex flex-col items-center justify-center p-4">
                <div class="max-w-xl w-full bg-white rounded-xl shadow-xl p-10 text-center border-2 border-dashed border-indigo-200 hover:border-indigo-400 transition-colors cursor-pointer group relative">
                    <div class="bg-indigo-50 w-24 h-24 rounded-full flex items-center justify-center mx-auto mb-6 group-hover:scale-105 transition-transform">
                        <i data-lucide="file-up" class="w-10 h-10 text-indigo-600"></i>
                    </div>
                    <h1 class="text-3xl font-bold text-slate-800 mb-3">PDFæ•´ç†ãƒ„ãƒ¼ãƒ«</h1>
                    <p class="text-slate-500 mb-8 text-lg">
                        PDFã‚’ã“ã“ã«ãƒ‰ãƒ­ãƒƒãƒ—ã—ã¦é–‹å§‹<br>
                        <span class="text-sm text-slate-400">ï¼ˆçµåˆãƒ»ä¸¦ã¹æ›¿ãˆãƒ»å‰Šé™¤ï¼‰</span>
                    </p>
                    <button id="select-file-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-8 rounded-lg transition-colors flex items-center justify-center mx-auto gap-2 shadow-lg hover:shadow-xl transform active:scale-95">
                        <i data-lucide="upload" class="w-5 h-5"></i>
                        ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ
                    </button>
                    <input type="file" id="initial-file-input" accept=".pdf" class="hidden" multiple />
                    
                    <p class="mt-8 text-xs text-slate-400 bg-slate-100 p-2 rounded inline-block">
                        ğŸ”’ ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã‚µãƒ¼ãƒãƒ¼ã«é€ä¿¡ã•ã‚Œãšã€ãƒ–ãƒ©ã‚¦ã‚¶å†…ã§å®‰å…¨ã«å‡¦ç†ã•ã‚Œã¾ã™ã€‚
                    </p>
                </div>
                
                <!-- Full screen drag overlay for initial screen -->
                <div id="file-drag-overlay" class="fixed inset-0 bg-indigo-600/90 z-50 flex items-center justify-center hidden">
                    <div class="text-white text-center pointer-events-none animate-bounce">
                        <i data-lucide="copy-plus" class="w-20 h-20 mx-auto mb-4"></i>
                        <h2 class="text-3xl font-bold">ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‰ãƒ­ãƒƒãƒ—ã—ã¦èª­ã¿è¾¼ã¿</h2>
                    </div>
                </div>
            </div>`;
        }

        function renderEditor() {
            const pagesHtml = state.pages.map((page, index) => `
                <div 
                    class="draggable-item relative group bg-white rounded-xl shadow-sm border-2 border-transparent hover:border-indigo-300 hover:shadow-md transition-all duration-200"
                    draggable="true"
                    data-index="${index}"
                >
                    <div class="preview-container aspect-[1/1.4] w-full bg-slate-100 rounded-t-lg overflow-visible relative">
                        <img src="${page.imageUrl}" class="w-full h-full object-contain pointer-events-none select-none rounded-t-lg" />
                        <div class="absolute inset-0 bg-black/0 group-hover:bg-black/5 transition-colors pointer-events-none rounded-t-lg"></div>
                        <button onclick="removePage(${index})" class="absolute top-2 right-2 bg-red-500 text-white p-1.5 rounded-full shadow-sm hover:bg-red-600 hover:scale-110 transition-all opacity-0 group-hover:opacity-100 z-10" title="å‰Šé™¤">
                            <i data-lucide="x" class="w-4 h-4"></i>
                        </button>
                    </div>
                    <div class="p-3 flex items-center justify-between bg-white rounded-b-xl border-t border-slate-100">
                        <div class="flex items-center gap-2">
                            <span class="w-6 h-6 flex items-center justify-center bg-slate-100 text-slate-500 text-xs font-bold rounded">${index + 1}</span>
                            <span class="text-[10px] text-slate-400 truncate max-w-[80px]" title="å…ƒã®ãƒšãƒ¼ã‚¸ç•ªå·">
                                ${state.sources.length > 1 ? 'FILE ' + (state.sources.findIndex(s => s.id === page.sourceId) + 1) + '-' : ''}${page.displayNumber}
                            </span>
                        </div>
                        <i data-lucide="move" class="w-4 h-4 text-slate-300 cursor-grab active:cursor-grabbing"></i>
                    </div>
                </div>
            `).join('');

            return `
            <header class="bg-white shadow-sm border-b sticky top-0 z-40">
                <div class="max-w-7xl mx-auto px-4 h-16 flex items-center justify-between">
                    <div class="flex items-center gap-3">
                        <div class="bg-indigo-600 p-1.5 rounded text-white shadow">
                            <i data-lucide="layers" class="w-5 h-5"></i>
                        </div>
                        <h1 class="font-bold text-lg text-slate-800 hidden sm:block">PDFæ•´ç†ãƒ„ãƒ¼ãƒ«</h1>
                        <button onclick="triggerAddFile()" class="ml-4 flex items-center gap-2 px-3 py-1.5 bg-slate-100 hover:bg-slate-200 text-slate-700 rounded-md text-sm font-medium transition-colors border border-slate-200">
                            <i data-lucide="plus" class="w-4 h-4"></i>
                            PDFã‚’è¿½åŠ 
                        </button>
                    </div>
                    <div class="flex gap-2">
                        <button onclick="resetAll()" class="px-4 py-2 text-slate-600 hover:bg-red-50 hover:text-red-600 rounded-lg text-sm font-medium transition-colors">
                            ã‚¯ãƒªã‚¢
                        </button>
                        <button onclick="saveNewPDF()" 
                            class="flex items-center gap-2 px-6 py-2 rounded-lg text-sm font-bold text-white transition-all transform active:scale-95 bg-indigo-600 hover:bg-indigo-700 shadow-lg hover:shadow-indigo-500/30">
                            <i data-lucide="download" class="w-4 h-4"></i>
                            ä¿å­˜ã™ã‚‹
                        </button>
                    </div>
                </div>
            </header>

            <main class="flex-1 max-w-7xl mx-auto px-4 py-8 w-full relative min-h-[calc(100vh-4rem)]">
                <div class="flex items-center justify-between mb-6 bg-blue-50 p-4 rounded-lg border border-blue-100">
                    <p class="text-blue-800 font-medium flex items-center gap-2">
                        <span class="bg-white px-2 py-0.5 rounded shadow-sm text-blue-600 font-bold text-lg">${state.pages.length}</span> ãƒšãƒ¼ã‚¸
                    </p>
                    <p class="text-xs sm:text-sm text-blue-600">
                        ç”»é¢ã«PDFã‚’ãƒ‰ãƒ­ãƒƒãƒ—ã—ã¦è¿½åŠ ã§ãã¾ã™
                    </p>
                </div>
                
                <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-6 pb-20 select-none">
                    ${pagesHtml}
                </div>

                ${state.pages.length === 0 ? `
                    <div class="text-center py-20">
                        <p class="text-slate-400">ãƒšãƒ¼ã‚¸ãŒã‚ã‚Šã¾ã›ã‚“</p>
                    </div>
                ` : ''}
            </main>

            <div id="file-drag-overlay" class="fixed inset-0 bg-indigo-600/90 z-50 flex items-center justify-center hidden backdrop-blur-sm">
                <div class="text-white text-center pointer-events-none">
                    <div class="bg-white/20 p-6 rounded-full w-32 h-32 flex items-center justify-center mx-auto mb-6 animate-pulse">
                        <i data-lucide="copy-plus" class="w-16 h-16"></i>
                    </div>
                    <h2 class="text-3xl font-bold mb-2">PDFã‚’è¿½åŠ </h2>
                    <p class="text-indigo-100 text-lg">ç¾åœ¨ã®ãƒšãƒ¼ã‚¸ã®æœ«å°¾ã«è¿½åŠ ã•ã‚Œã¾ã™</p>
                </div>
            </div>
            `;
        }

        function setupInitialUploadEvents() {
            const fileInput = document.getElementById('initial-file-input');
            const selectBtn = document.getElementById('select-file-btn');
            
            if(selectBtn) selectBtn.addEventListener('click', () => fileInput.click());
            if(fileInput) fileInput.addEventListener('change', handleFileSelect);
            
            // ãƒ‰ãƒ­ãƒƒãƒ—å‡¦ç†ã¯ setupGlobalDragEvents ã«ä¸€å…ƒåŒ–ã—ã¾ã—ãŸ
        }

        function setupEditorEvents() {
            const items = document.querySelectorAll('.draggable-item');
            items.forEach(item => {
                const index = parseInt(item.dataset.index);
                item.addEventListener('dragstart', (e) => handlePageDragStart(e, index));
                item.addEventListener('dragover', (e) => handlePageDragOver(e, index));
                item.addEventListener('drop', handlePageDrop);
                item.addEventListener('dragend', handlePageDragEnd);
            });
        }

        window.removePage = removePage;
        window.resetAll = resetAll;
        window.saveNewPDF = saveNewPDF;
        window.triggerAddFile = triggerAddFile;

    </script>
</body>
</html>
