<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF整理ツール</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- PDF Libraries -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        body { font-family: 'Inter', system-ui, -apple-system, sans-serif; }
        .drag-over { border-color: #6366f1 !important; background-color: #eef2ff; }
        .dragging { opacity: 0.5; transform: scale(0.95); }
        
        /* Spinner Animation */
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .animate-spin { animation: spin 1s linear infinite; }
    </style>
</head>
<body class="bg-slate-100 min-h-screen text-slate-800">

    <div id="app" class="min-h-screen flex flex-col">
        <!-- Content will be injected here by JavaScript -->
    </div>

    <script>
        // --- State Management ---
        const state = {
            pdfFile: null,
            pages: [], // { id, originalIndex, displayNumber, imageUrl }
            isProcessing: false,
            progress: 0,
            originalPdfBytes: null,
            draggedItemIndex: null
        };

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            // Set worker source for PDF.js
            if (window.pdfjsLib) {
                window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
            }
            render();
        });

        // --- Core Logic ---

        async function handleFileSelect(event) {
            const file = event.target.files ? event.target.files[0] : event.dataTransfer.files[0];
            if (file && file.type === 'application/pdf') {
                await processPDF(file);
            } else {
                alert('PDFファイルを選択してください。');
            }
        }

        async function processPDF(file) {
            if (!window.pdfjsLib) {
                alert("ライブラリの読み込みが完了していません。リロードしてください。");
                return;
            }

            state.isProcessing = true;
            state.progress = 0;
            state.pdfFile = file;
            state.pages = [];
            render();

            try {
                const arrayBuffer = await file.arrayBuffer();
                
                // CRITICAL FIX: Clone buffer for pdf-lib usage later
                state.originalPdfBytes = arrayBuffer.slice(0);

                const loadingTask = window.pdfjsLib.getDocument(arrayBuffer);
                const pdf = await loadingTask.promise;
                const numPages = pdf.numPages;

                const newPages = [];

                for (let i = 1; i <= numPages; i++) {
                    const page = await pdf.getPage(i);
                    const viewport = page.getViewport({ scale: 0.5 });
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;

                    await page.render({
                        canvasContext: context,
                        viewport: viewport
                    }).promise;

                    newPages.push({
                        id: `page-${i}-${Date.now()}`,
                        originalIndex: i - 1,
                        displayNumber: i,
                        imageUrl: canvas.toDataURL()
                    });

                    state.progress = Math.round((i / numPages) * 100);
                    render(); // Update progress UI
                }

                state.pages = newPages;
            } catch (error) {
                console.error("Error processing PDF:", error);
                alert("PDFの読み込みに失敗しました。パスワード付きPDFなどは対応していない場合があります。");
                state.pdfFile = null;
            } finally {
                state.isProcessing = false;
                render();
            }
        }

        async function saveNewPDF() {
            if (!state.originalPdfBytes || state.pages.length === 0) return;

            state.isProcessing = true;
            render();

            try {
                const { PDFDocument } = window.PDFLib;
                
                // Load original from cloned buffer
                const pdfDoc = await PDFDocument.load(state.originalPdfBytes);
                const newPdfDoc = await PDFDocument.create();

                const indicesToCopy = state.pages.map(p => p.originalIndex);
                const copiedPages = await newPdfDoc.copyPages(pdfDoc, indicesToCopy);

                copiedPages.forEach(page => newPdfDoc.addPage(page));

                const pdfBytes = await newPdfDoc.save();
                
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `edited_${state.pdfFile.name}`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

            } catch (error) {
                console.error("Error saving PDF:", error);
                alert("保存中にエラーが発生しました。");
            } finally {
                state.isProcessing = false;
                render();
            }
        }

        function resetAll() {
            if (confirm("すべての変更を破棄して初期状態に戻しますか？")) {
                state.pdfFile = null;
                state.pages = [];
                state.originalPdfBytes = null;
                render();
            }
        }

        function removePage(index) {
            state.pages.splice(index, 1);
            render();
        }

        function movePage(index, direction) {
            if (direction === 'left' && index > 0) {
                [state.pages[index], state.pages[index - 1]] = [state.pages[index - 1], state.pages[index]];
            } else if (direction === 'right' && index < state.pages.length - 1) {
                [state.pages[index], state.pages[index + 1]] = [state.pages[index + 1], state.pages[index]];
            }
            render();
        }

        // --- Drag and Drop Logic ---
        
        function handleDragStart(e, index) {
            state.draggedItemIndex = index;
            e.dataTransfer.effectAllowed = "move";
            e.dataTransfer.setData('text/plain', index); // Required for Firefox
            e.target.closest('.draggable-item').classList.add('dragging');
        }

        function handleDragOver(e, index) {
            e.preventDefault();
            if (state.draggedItemIndex === null || state.draggedItemIndex === index) return;

            const draggedItem = state.pages[state.draggedItemIndex];
            state.pages.splice(state.draggedItemIndex, 1);
            state.pages.splice(index, 0, draggedItem);
            
            state.draggedItemIndex = index;
            render();
            
            // Re-apply dragging class after render
            const items = document.querySelectorAll('.draggable-item');
            if(items[index]) items[index].classList.add('dragging');
        }

        function handleDragEnd(e) {
            state.draggedItemIndex = null;
            document.querySelectorAll('.draggable-item').forEach(el => el.classList.remove('dragging'));
            render();
        }

        // --- Rendering ---

        function render() {
            const app = document.getElementById('app');
            app.innerHTML = ''; // Clear current content

            // 1. Loading / Processing State
            if (state.isProcessing && state.pages.length === 0) {
                app.innerHTML = renderProcessing();
                lucide.createIcons();
                return;
            }

            // 2. Initial Upload State
            if (!state.pdfFile) {
                app.innerHTML = renderUpload();
                setupUploadEvents();
            } else {
                // 3. Main Editor State
                app.innerHTML = renderEditor();
                setupEditorEvents();
            }
            
            lucide.createIcons();
        }

        function renderUpload() {
            return `
            <div class="min-h-screen bg-slate-50 flex flex-col items-center justify-center p-4">
                <div id="drop-zone" class="max-w-xl w-full bg-white rounded-xl shadow-xl p-8 text-center border-2 border-dashed border-indigo-200 hover:border-indigo-400 transition-colors cursor-pointer">
                    <div class="bg-indigo-50 w-20 h-20 rounded-full flex items-center justify-center mx-auto mb-6">
                        <i data-lucide="file-up" class="w-10 h-10 text-indigo-600"></i>
                    </div>
                    <h1 class="text-2xl font-bold text-slate-800 mb-2">PDF整理ツール</h1>
                    <p class="text-slate-500 mb-6">PDFをここにドラッグ＆ドロップするか、クリックして選択してください。</p>
                    <button id="select-file-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-8 rounded-lg transition-colors flex items-center justify-center mx-auto gap-2">
                        <i data-lucide="upload" class="w-5 h-5"></i>
                        ファイルを選択
                    </button>
                    <input type="file" id="file-input" accept=".pdf" class="hidden" />
                    <p class="mt-8 text-xs text-slate-400">
                        ※ファイルはサーバーにアップロードされず、お使いのブラウザ内でのみ処理されます。
                    </p>
                </div>
            </div>`;
        }

        function renderProcessing() {
            return `
            <div class="min-h-screen flex flex-col items-center justify-center bg-slate-100">
                <div class="w-12 h-12 border-4 border-indigo-200 border-t-indigo-600 rounded-full animate-spin mb-4"></div>
                <p class="text-slate-600 font-medium">PDFを読み込んでいます...</p>
                <p class="text-slate-400 text-sm mt-1">${state.progress}% 完了</p>
            </div>`;
        }

        function renderEditor() {
            const pagesHtml = state.pages.map((page, index) => `
                <div 
                    class="draggable-item relative group bg-white rounded-lg shadow-sm border-2 border-transparent hover:border-indigo-300 hover:shadow-md transition-all duration-200 cursor-move"
                    draggable="true"
                    data-index="${index}"
                >
                    <!-- Page Preview -->
                    <div class="aspect-[1/1.4] w-full bg-slate-100 rounded-t-lg overflow-hidden relative">
                        <img src="${page.imageUrl}" class="w-full h-full object-contain pointer-events-none select-none" />
                        <div class="absolute inset-0 bg-black/0 group-hover:bg-black/5 transition-colors pointer-events-none"></div>
                        
                        <!-- Delete Button -->
                        <button onclick="removePage(${index})" class="absolute top-2 right-2 bg-red-500 text-white p-1.5 rounded-full shadow-sm hover:bg-red-600 hover:scale-110 transition-all opacity-0 group-hover:opacity-100" title="削除">
                            <i data-lucide="x" class="w-4 h-4"></i>
                        </button>
                    </div>

                    <!-- Footer -->
                    <div class="p-3 flex items-center justify-between bg-white rounded-b-lg border-t border-slate-100">
                        <div class="flex items-center gap-2">
                            <span class="w-6 h-6 flex items-center justify-center bg-slate-100 text-slate-500 text-xs font-bold rounded">${index + 1}</span>
                            <span class="text-xs text-slate-400">(元: ${page.displayNumber}P)</span>
                        </div>
                        <div class="flex gap-1 opacity-100 sm:opacity-0 group-hover:opacity-100 transition-opacity">
                            <button onclick="movePage(${index}, 'left')" class="p-1 text-slate-400 hover:text-indigo-600 disabled:opacity-30" ${index === 0 ? 'disabled' : ''}>
                                <i data-lucide="arrow-left" class="w-4 h-4"></i>
                            </button>
                            <button onclick="movePage(${index}, 'right')" class="p-1 text-slate-400 hover:text-indigo-600 disabled:opacity-30" ${index === state.pages.length - 1 ? 'disabled' : ''}>
                                <i data-lucide="arrow-right" class="w-4 h-4"></i>
                            </button>
                        </div>
                    </div>
                </div>
            `).join('');

            return `
            <!-- Header -->
            <header class="bg-white shadow-sm border-b sticky top-0 z-10">
                <div class="max-w-7xl mx-auto px-4 h-16 flex items-center justify-between">
                    <div class="flex items-center gap-2">
                        <div class="bg-indigo-600 p-1.5 rounded text-white">
                            <i data-lucide="refresh-cw" class="w-5 h-5"></i>
                        </div>
                        <h1 class="font-bold text-lg text-slate-800 hidden sm:block">PDF整理ツール</h1>
                        <span class="text-slate-400 text-sm hidden sm:block">|</span>
                        <span class="text-slate-600 text-sm truncate max-w-[150px] sm:max-w-md">${state.pdfFile.name}</span>
                    </div>
                    <div class="flex gap-2">
                        <button onclick="resetAll()" class="px-4 py-2 text-slate-600 hover:bg-slate-100 rounded-lg text-sm font-medium transition-colors">やり直す</button>
                        <button onclick="saveNewPDF()" 
                            class="flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-medium text-white transition-colors ${state.isProcessing || state.pages.length === 0 ? 'bg-indigo-300 cursor-not-allowed' : 'bg-indigo-600 hover:bg-indigo-700 shadow-md'}"
                            ${state.isProcessing || state.pages.length === 0 ? 'disabled' : ''}>
                            <i data-lucide="download" class="w-4 h-4"></i>
                            ${state.isProcessing ? '処理中...' : 'PDFを保存'}
                        </button>
                    </div>
                </div>
            </header>

            <!-- Main -->
            <main class="flex-1 max-w-7xl mx-auto px-4 py-8 w-full">
                ${state.isProcessing ? renderProcessing() : `
                    <div class="flex items-center justify-between mb-6">
                        <p class="text-slate-600">
                            <span class="font-bold text-slate-900">${state.pages.length}</span> ページ
                            <span class="text-sm ml-2 text-slate-400">（ドラッグして並べ替え、×ボタンで削除）</span>
                        </p>
                    </div>
                    
                    <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-6 pb-20">
                        ${pagesHtml}
                    </div>

                    ${state.pages.length === 0 ? `
                        <div class="text-center py-20 border-2 border-dashed border-slate-200 rounded-xl">
                            <i data-lucide="trash-2" class="w-12 h-12 text-slate-300 mx-auto mb-3"></i>
                            <p class="text-slate-500">すべてのページが削除されました</p>
                            <button onclick="resetAll()" class="text-indigo-600 hover:underline text-sm mt-2">最初からやり直す</button>
                        </div>
                    ` : ''}
                `}
            </main>
            `;
        }

        // --- Event Listeners Setup ---

        function setupUploadEvents() {
            const dropZone = document.getElementById('drop-zone');
            const fileInput = document.getElementById('file-input');
            const selectBtn = document.getElementById('select-file-btn');

            selectBtn.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handleFileSelect);

            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('drag-over');
            });
            dropZone.addEventListener('dragleave', () => dropZone.classList.remove('drag-over'));
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');
                handleFileSelect(e);
            });
        }

        function setupEditorEvents() {
            const items = document.querySelectorAll('.draggable-item');
            items.forEach(item => {
                const index = parseInt(item.dataset.index);
                item.addEventListener('dragstart', (e) => handleDragStart(e, index));
                item.addEventListener('dragover', (e) => handleDragOver(e, index));
                item.addEventListener('dragend', handleDragEnd);
            });
        }

        // Expose functions to global scope for inline onclick handlers
        window.removePage = removePage;
        window.movePage = movePage;
        window.resetAll = resetAll;
        window.saveNewPDF = saveNewPDF;

    </script>
</body>
</html>
